/* UDP send datagram - audio library
 * Example: Create an audio loop between two hosts
 *          Send Sine (Out CH 0) -> 
 *          Loop: Recv (In Ch 0) -> Recv (Out Ch0) -> [and DAC on T3.5 or 6]
 *          Loop: Send (In Ch 0) -> Send (Out Ch 1) -> 
 *          Recv (In Ch 1)  -> DAC    
 * using Teensy Audio library and EtherNet Library
 * WIZ 5500 preferred
 * EtherNet DOES NOT have an ISR() so something that does is required in the sketch for packets to flow 
 * - A DAC is OK for T 3.x, but the T 4.0 does not have one, so perhaps use SPDIF
 */

#define DEBUG 1 // > 0 for debug messages to Serial Monitor

// Ethernet shield attached to pins SS=10, MOSI=11, MISO=12, SCK=13

#define ResetWIZ_PIN 9
#define WIZ_CS_PIN 10 

// Enter a Device ID, which generates the MAC and IP addresses for your controller.
// this must go before the autogenerated code, or the defaults will be used
#define MYID 2

// begin automatic code
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// GUItool: begin automatically generated code
AudioOutputSPDIF         spdif1;           // need something with an ISR to make update() work - no DAC on T4
AudioControlEtherNet     EtherNet1;      
AudioSynthWaveformSine   sine1;          
AudioOutputNet           net_out1;     
AudioInputNet            net_in1;       
AudioConnection          patchCord1(sine1,   0, net_out1, 0);
AudioConnection          patchCord3(net_in1, 0, net_out1, 1);
AudioConnection          patchCord2(sine1,   0, spdif1, 0);
// GUItool: end automatically generated code

short targetID = TARGET_BCAST; // using TARGET_BCAST to broadcast messages i.e. last byte of IP is 255 (Class C)

#define SINCONTROL 129
typedef struct sineMessage // user-defined control packet
{
  byte channel;
  short freq;
  float ampl;
} sinMsg;

sinMsg mySin;

void setup() {
    AudioMemory(40);   
#if DEBUG >0
  Serial.begin(38400);
   while (!Serial) 
    delay(1); 
  Serial.println("Hello world! SEND");
#endif  
  EtherNet1.enable(); // order is important - start the control first
  //net_out1.begin();
  //net_in1.begin();
  EtherNet1.setMyID(MYID);

  net_out1.setControl(&EtherNet1);  
  net_out1.setAudioTargetID(TARGET_BCAST);
  net_out1.setStreamName("Stream_A");
  
  net_in1.setControl(&EtherNet1);
 
  sine1.frequency(440);
  sine1.amplitude(0.9);
  
#if DEBUG > 0   
      printDiagnostics();
#endif
}

#define TIME_PRINT_EVERY 5 // secs

bool subscribed1 = false;
controlQueue cQbuf;
short streamsAvail;

void loop() {  
  // subscribe to an input stream - mandatory for inputs
  if(!subscribed1) // in loop() as streams are not guaranteed to be available in setup()
  {
       streamsAvail = EtherNet1.getActiveStreams(); // Ethernet control owns the streams
#if DEBUG > 0
      if (streamsAvail > 0)
        printStreams();
#endif   
      // Subscribe to an incoming stream, via an input control, once they become available 
      if(streamsAvail > 0)
          subscribed1 = net_in1.subscribeStream( 0 );  // using streamID = 0 as an example
  } 
  
  // read control packets - mandatory
  while (EtherNet1.getQueuedUserControlMsg(&cQbuf)) // need to regularly read the control queue for incoming messages  
      ; // process any messages we care about
        
#if DEBUG > 0
// Above is all that is required. Below is simply diagnostics.
    if((micros() % (TIME_PRINT_EVERY * 1000000)) == 0) // print every few seconds
    {
         printGeneralStats();     
         printStreams();
    }     
#endif    
}
void printStreams()
{
  short i, maxStream;
  netAudioStream stream;
  maxStream = EtherNet1.getActiveStreams();
  Serial.print("\nStreams\n");
  for (i = 0; i < maxStream; i++)
  {
      stream = EtherNet1.getStream(i);
      Serial.print("Name: "); Serial.print(stream.streamName); 
      Serial.print(", Host: "); Serial.print(stream.remoteHostID);
      Serial.print(", Stream: "); Serial.print(stream.hostStreamID);
      Serial.print(", Active: "); Serial.println(stream.active ? " Y": " N");
  }
}
void printDiagnostics()
{
short wiztype;
    // Check for Ethernet hardware present
    // Warning: very few direct calls to the Ethernet library may be executed from a user program, as most directly issue SPI transactions.
    if ((wiztype = Ethernet.hardwareStatus()) == EthernetNoHardware) {
      Serial.println("Ethernet shield was not found.  Sorry, can't run without hardware.");   
    }
    else {
        Serial.print("Found WIZ type ");
        Serial.println(wiztype);    
    }
    printIP("My IP is ", EtherNet1.getMyIP());
    Serial.print("Ethernet cable connected = ");
    Serial.println(EtherNet1.getLinkStatus() ? "Yes" : "No");
    Serial.print("Audio Memory "); Serial.println(AudioMemoryUsage());
    Serial.println("Exiting setup() - ethernet link may take some time to connect. \n______________________");
}
void printGeneralStats()
{
        Serial.print("\nEthernet cable connected = ");
        Serial.println(EtherNet1.getLinkStatus() ? "Yes" : "No");
        Serial.print("Processor (Curr/Max) = ");  Serial.print(AudioProcessorUsage());
        Serial.print("/"); Serial.print(AudioProcessorUsageMax());   
        Serial.print(". Audio Memory (Curr/Max) = ");  Serial.print(AudioMemoryUsage());
        Serial.print("/"); Serial.print(AudioMemoryUsageMax());  
}

void printIP(char text[], IPAddress buf){
  short j;
     Serial.print(text);
     for (j=0; j<4; j++){
       Serial.print(buf[j]); Serial.print(" ");
     }
     Serial.println();
}
